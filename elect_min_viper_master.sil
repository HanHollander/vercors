domain Process {
  
  function p_is_choice(p1: Process, p2: Process): Bool
  
  function p_empty(): Process
  
  function p_merge(p1: Process, p2: Process): Process
  
  function p_choice(p1: Process, p2: Process): Process
  
  function p_seq(p1: Process, p2: Process): Process
  
  function p_method_Future_Send__Integer__Integer(rank: Int, msg: Int): Process
  
  function p_method_Future_Recv__Integer__Integer(rank: Int, msg: Int): Process
  
  function p_method_Future_Done__Integer__Integer(rank: Int, v: Int): Process
  
  function p_method_Future_SigmaRecv__Integer__Integer__Integer__Integer__Integer__Integer(rank: Int, size: Int, v: Int, w: Int, max: Int, n: Int): Process
  
  function p_method_Future_Check__Integer__Integer__Integer__Integer__Integer__Integer(rank: Int, size: Int, v: Int, w: Int, max: Int, n: Int): Process
  
  function p_method_Future_Elect__Integer__Integer__Integer__Integer__Integer(rank: Int, size: Int, v: Int, max: Int, n: Int): Process
  
  function p_method_Future_Spawn__Integer__Integer__Sequence$Integer$__Integer(rank: Int, size: Int, xs: Seq[Int], max: Int): Process
  
  function p_method_Future_Start__Integer__Sequence$Integer$__Integer(size: Int, xs: Seq[Int], max: Int): Process
  
  axiom empty_1L {
    (forall p: Process :: { p_merge(p_empty(), p) } p_merge(p_empty(), p) == p)
  }
  
  axiom empty_2L {
    (forall p: Process :: { p_seq(p_empty(), p) } p_seq(p_empty(), p) == p)
  }
  
  axiom empty_2R {
    (forall p: Process :: { p_seq(p, p_empty()) } p_seq(p, p_empty()) == p)
  }
  
  axiom choice_L {
    (forall p1: Process, p2: Process :: { p_is_choice(p_choice(p1, p2), p1) } p_is_choice(p_choice(p1, p2), p1))
  }
  
  axiom choice_R {
    (forall p1: Process, p2: Process :: { p_is_choice(p_choice(p1, p2), p2) } p_is_choice(p_choice(p1, p2), p2))
  }
  
  axiom choice_dist {
    (forall p1: Process, p2: Process, p3: Process :: { p_seq(p_choice(p1, p2), p3) } p_seq(p_choice(p1, p2), p3) == p_choice(p_seq(p1, p3), p_seq(p2, p3)))
  }
  
  axiom seq_assoc {
    (forall p1: Process, p2: Process, p3: Process :: { p_seq(p_seq(p1, p2), p3) } p_seq(p_seq(p1, p2), p3) == p_seq(p1, p_seq(p2, p3)))
  }
  
  axiom method_Future_Send__Integer__Integer_def_2 {
    (forall p: Process, rank: Int, msg: Int :: { p_seq(p, p_method_Future_Send__Integer__Integer(rank, msg)) } p_seq(p, p_method_Future_Send__Integer__Integer(rank, msg)) == p_seq(p, p_seq(p_method_Future_Send__Integer__Integer(rank, msg), p_empty())))
  }
  
  axiom method_Future_Recv__Integer__Integer_def_2 {
    (forall p: Process, rank: Int, msg: Int :: { p_seq(p, p_method_Future_Recv__Integer__Integer(rank, msg)) } p_seq(p, p_method_Future_Recv__Integer__Integer(rank, msg)) == p_seq(p, p_seq(p_method_Future_Recv__Integer__Integer(rank, msg), p_empty())))
  }
  
  axiom method_Future_Done__Integer__Integer_def_2 {
    (forall p: Process, rank: Int, v: Int :: { p_seq(p, p_method_Future_Done__Integer__Integer(rank, v)) } p_seq(p, p_method_Future_Done__Integer__Integer(rank, v)) == p_seq(p, p_seq(p_method_Future_Done__Integer__Integer(rank, v), p_empty())))
  }
  
  axiom method_Future_SigmaRecv__Integer__Integer__Integer__Integer__Integer__Integer_def_1 {
    (forall rank: Int, size: Int, v: Int, w: Int, max: Int, n: Int :: { p_method_Future_SigmaRecv__Integer__Integer__Integer__Integer__Integer__Integer(rank, size, v, w, max, n) } (0 < w ? p_choice(p_seq(p_method_Future_Recv__Integer__Integer((rank - 1) % size, w), p_method_Future_Check__Integer__Integer__Integer__Integer__Integer__Integer(rank, size, v, w, max, n)), p_method_Future_SigmaRecv__Integer__Integer__Integer__Integer__Integer__Integer(rank, size, v, w - 1, max, n)) : p_seq(p_method_Future_Recv__Integer__Integer((rank - 1) % size, w), p_method_Future_Check__Integer__Integer__Integer__Integer__Integer__Integer(rank, size, v, w, max, n))) == p_method_Future_SigmaRecv__Integer__Integer__Integer__Integer__Integer__Integer(rank, size, v, w, max, n))
  }
  
  axiom method_Future_SigmaRecv__Integer__Integer__Integer__Integer__Integer__Integer_def_2 {
    (forall p: Process, rank: Int, size: Int, v: Int, w: Int, max: Int, n: Int :: { p_seq(p, p_method_Future_SigmaRecv__Integer__Integer__Integer__Integer__Integer__Integer(rank, size, v, w, max, n)) } p_seq(p, p_method_Future_SigmaRecv__Integer__Integer__Integer__Integer__Integer__Integer(rank, size, v, w, max, n)) == p_seq(p, p_seq(p_method_Future_SigmaRecv__Integer__Integer__Integer__Integer__Integer__Integer(rank, size, v, w, max, n), p_empty())))
  }
  
  axiom method_Future_Check__Integer__Integer__Integer__Integer__Integer__Integer_def_1 {
    (forall rank: Int, size: Int, v: Int, w: Int, max: Int, n: Int :: { p_method_Future_Check__Integer__Integer__Integer__Integer__Integer__Integer(rank, size, v, w, max, n) } p_method_Future_Elect__Integer__Integer__Integer__Integer__Integer(rank, size, (v <= w ? w : v), max, n + 1) == p_method_Future_Check__Integer__Integer__Integer__Integer__Integer__Integer(rank, size, v, w, max, n))
  }
  
  axiom method_Future_Check__Integer__Integer__Integer__Integer__Integer__Integer_def_2 {
    (forall p: Process, rank: Int, size: Int, v: Int, w: Int, max: Int, n: Int :: { p_seq(p, p_method_Future_Check__Integer__Integer__Integer__Integer__Integer__Integer(rank, size, v, w, max, n)) } p_seq(p, p_method_Future_Check__Integer__Integer__Integer__Integer__Integer__Integer(rank, size, v, w, max, n)) == p_seq(p, p_seq(p_method_Future_Check__Integer__Integer__Integer__Integer__Integer__Integer(rank, size, v, w, max, n), p_empty())))
  }
  
  axiom method_Future_Elect__Integer__Integer__Integer__Integer__Integer_def_1 {
    (forall rank: Int, size: Int, v: Int, max: Int, n: Int :: { p_method_Future_Elect__Integer__Integer__Integer__Integer__Integer(rank, size, v, max, n) } (n < size ? p_seq(p_method_Future_Send__Integer__Integer((rank + 1) % size, v), p_method_Future_SigmaRecv__Integer__Integer__Integer__Integer__Integer__Integer(rank, size, v, max - 1, max, n)) : p_method_Future_Done__Integer__Integer(rank, v)) == p_method_Future_Elect__Integer__Integer__Integer__Integer__Integer(rank, size, v, max, n))
  }
  
  axiom method_Future_Elect__Integer__Integer__Integer__Integer__Integer_def_2 {
    (forall p: Process, rank: Int, size: Int, v: Int, max: Int, n: Int :: { p_seq(p, p_method_Future_Elect__Integer__Integer__Integer__Integer__Integer(rank, size, v, max, n)) } p_seq(p, p_method_Future_Elect__Integer__Integer__Integer__Integer__Integer(rank, size, v, max, n)) == p_seq(p, p_seq(p_method_Future_Elect__Integer__Integer__Integer__Integer__Integer(rank, size, v, max, n), p_empty())))
  }
  
  axiom method_Future_Spawn__Integer__Integer__Sequence$Integer$__Integer_def_1 {
    (forall rank: Int, size: Int, xs: Seq[Int], max: Int :: { p_method_Future_Spawn__Integer__Integer__Sequence$Integer$__Integer(rank, size, xs, max) } (rank < size ? p_merge(p_method_Future_Elect__Integer__Integer__Integer__Integer__Integer(rank, size, xs[rank], max, 0), p_method_Future_Spawn__Integer__Integer__Sequence$Integer$__Integer(rank + 1, size, xs, max)) : p_empty()) == p_method_Future_Spawn__Integer__Integer__Sequence$Integer$__Integer(rank, size, xs, max))
  }
  
  axiom method_Future_Spawn__Integer__Integer__Sequence$Integer$__Integer_def_2 {
    (forall p: Process, rank: Int, size: Int, xs: Seq[Int], max: Int :: { p_seq(p, p_method_Future_Spawn__Integer__Integer__Sequence$Integer$__Integer(rank, size, xs, max)) } p_seq(p, p_method_Future_Spawn__Integer__Integer__Sequence$Integer$__Integer(rank, size, xs, max)) == p_seq(p, p_seq(p_method_Future_Spawn__Integer__Integer__Sequence$Integer$__Integer(rank, size, xs, max), p_empty())))
  }
  
  axiom method_Future_Start__Integer__Sequence$Integer$__Integer_def_1 {
    (forall size: Int, xs: Seq[Int], max: Int :: { p_method_Future_Start__Integer__Sequence$Integer$__Integer(size, xs, max) } p_method_Future_Spawn__Integer__Integer__Sequence$Integer$__Integer(0, size, xs, max) == p_method_Future_Start__Integer__Sequence$Integer$__Integer(size, xs, max))
  }
  
  axiom method_Future_Start__Integer__Sequence$Integer$__Integer_def_2 {
    (forall p: Process, size: Int, xs: Seq[Int], max: Int :: { p_seq(p, p_method_Future_Start__Integer__Sequence$Integer$__Integer(size, xs, max)) } p_seq(p, p_method_Future_Start__Integer__Sequence$Integer$__Integer(size, xs, max)) == p_seq(p, p_seq(p_method_Future_Start__Integer__Sequence$Integer$__Integer(size, xs, max), p_empty())))
  }
}

domain frac {
  
  function frac_val(a: frac): Perm
  
  axiom frac_eq {
    (forall a: frac, b: frac :: { frac_val(a),frac_val(b) } (frac_val(a) == frac_val(b)) == (a == b))
  }
  
  axiom frac_bound {
    (forall a: frac :: { frac_val(a) } 0 / 1 < frac_val(a) && frac_val(a) <= 1 / 1)
  }
}

domain zfrac {
  
  function zfrac_val(a: zfrac): Perm
  
  axiom zfrac_eq {
    (forall a: zfrac, b: zfrac :: { zfrac_val(a),zfrac_val(b) } (zfrac_val(a) == zfrac_val(b)) == (a == b))
  }
  
  axiom zfrac_bound {
    (forall a: zfrac :: { zfrac_val(a) } 0 / 1 <= zfrac_val(a) && zfrac_val(a) <= 1 / 1)
  }
}

//  a field 
field channel_hist_value: Seq[Seq[Int]]

//  a field 
field channel_hist_act: Seq[Seq[Int]]

//  a field 
field channel_hist_write: Seq[Seq[Int]]

//  a field 
field channel_hist_hist: Seq[Seq[Int]]

//  a field 
field channel_hist_action: Seq[Seq[Int]]

//  a field 
field results_hist_value: Seq[Int]

//  a field 
field results_hist_act: Seq[Int]

//  a field 
field results_hist_write: Seq[Int]

//  a field 
field results_hist_hist: Seq[Int]

//  a field 
field results_hist_action: Seq[Int]

//  a field 
field field_Program_initialised: Bool

//  a field 
field field_Program_size: Int

//  a field 
field field_Program_maxvalue: Int

//  a field 
field field_Program_f: Ref

function method_Program_update__Sequence$Integer$__Integer__Integer(xs: Seq[Int], i: Int, v: Int): Seq[Int]
  requires 0 <= i && i < |xs|
  ensures |result| == |xs|
  ensures result[i] == v
  ensures (forall j: Int :: { result[j] } { xs[j] } 0 <= j && j < |xs| && j != i ==> result[j] == xs[j])
{
  (0 < i ? Seq(xs[0]) ++ method_Program_update__Sequence$Integer$__Integer__Integer(xs[1..], i - 1, v) : Seq(v) ++ xs[1..])
}

function method_Program_maxint__Sequence$Integer$__Integer__Integer(xs: Seq[Int], i: Int, j: Int): Int
  requires 0 <= i && i <= |xs|
  requires 0 <= j && j < |xs|
  requires (forall l: Int :: { xs[l] } 0 <= l && l < i ==> xs[l] <= xs[j])
  ensures 0 <= result && result < |xs|
  ensures xs[j] <= xs[result]
  ensures (forall l: Int :: { xs[l] } i <= l && l < |xs| ==> xs[l] <= xs[result])
{
  (i < |xs| ? (xs[j] <= xs[i] ? method_Program_maxint__Sequence$Integer$__Integer__Integer(xs, i + 1, i) : method_Program_maxint__Sequence$Integer$__Integer__Integer(xs, i + 1, j)) : j)
}

function method_Program_push__Sequence$Sequence$Integer$$__Integer__Integer(diz: Ref, xs: Seq[Seq[Int]], i: Int, val: Int): Seq[Seq[Int]]
  requires diz != null
  requires 0 <= i && i < |xs|
  ensures |result| == |xs|
  ensures result[i] == xs[i] ++ Seq(val)
  ensures (forall j: Int :: { result[j] } { xs[j] } 0 <= j && j < |xs| && j != i ==> result[j] == xs[j])
{
  (0 < i ? Seq(xs[0]) ++ method_Program_push__Sequence$Sequence$Integer$$__Integer__Integer(diz, xs[1..], i - 1, val) : Seq(xs[0] ++ Seq(val)) ++ xs[1..])
}

function method_Program_pop__Sequence$Sequence$Integer$$__Integer(diz: Ref, xs: Seq[Seq[Int]], i: Int): Seq[Seq[Int]]
  requires diz != null
  requires 0 <= i && i < |xs|
  ensures |result| == |xs|
  ensures result[i] == xs[i][1..]
  ensures (forall j: Int :: { result[j] } { xs[j] } 0 <= j && j < |xs| && j != i ==> result[j] == xs[j])
{
  (0 < i ? Seq(xs[0]) ++ method_Program_pop__Sequence$Sequence$Integer$$__Integer(diz, xs[1..], i - 1) : Seq(xs[0][1..]) ++ xs[1..])
}


predicate hist_do_method_Future_Send__Integer__Integer(diz: Ref, fr: frac, proc: Process) 

predicate hist_do_method_Future_Recv__Integer__Integer(diz: Ref, fr: frac, proc: Process) 

predicate hist_do_method_Future_Done__Integer__Integer(diz: Ref, fr: frac, proc: Process) 

predicate hist_idle(diz: Ref, fr: frac, proc: Process) 

predicate method_Program_lock_held(diz: Ref, globals: Ref) 

predicate method_Program_lock_invariant(diz: Ref, globals: Ref) {
  diz != null && (acc(diz.field_Program_initialised, 1 / 2) && acc(diz.field_Program_size, 1 / 2) && acc(diz.field_Program_maxvalue, 1 / 2) && 0 < diz.field_Program_maxvalue && (diz.field_Program_initialised ? acc(diz.field_Program_f, 1 / 2) && diz.field_Program_f != null : true) && (diz.field_Program_initialised ? acc(diz.field_Program_f.channel_hist_value, write) && acc(diz.field_Program_f.channel_hist_hist, write) && diz.field_Program_size == |diz.field_Program_f.channel_hist_value| : true) && (diz.field_Program_initialised ? acc(diz.field_Program_f.results_hist_value, write) && acc(diz.field_Program_f.results_hist_hist, write) && diz.field_Program_size == |diz.field_Program_f.results_hist_value| : true) && (diz.field_Program_initialised ==> (forall i: Int, j: Int :: { diz.field_Program_f.channel_hist_value[i][j] } 0 <= i && i < diz.field_Program_size && (0 <= j && j < |diz.field_Program_f.channel_hist_value[i]|) ==> 0 <= diz.field_Program_f.channel_hist_value[i][j] && diz.field_Program_f.channel_hist_value[i][j] < diz.field_Program_maxvalue)))
}

/* REMOVING THESE TWO MAKES STABLE? */
predicate method_Main_joinToken(diz: Ref, globals: Ref) 

predicate method_Main_idleToken(diz: Ref, globals: Ref) 

method method_Future_Send__Integer__Integer_begin(diz: Ref, current_thread_id: Int, fr: frac, proc: Process, rank: Int, msg: Int)
  requires diz != null
  requires 0 <= current_thread_id
  requires frac_val(fr) != none
  requires acc(hist_idle(diz, fr, p_seq(p_method_Future_Send__Integer__Integer(rank, msg), proc)), write)
  requires write != none
  requires acc(diz.channel_hist_value, write)
  requires acc(diz.channel_hist_hist, write)
  requires 0 <= rank && rank < |diz.channel_hist_value|
  ensures frac_val(fr) != none
  ensures acc(hist_do_method_Future_Send__Integer__Integer(diz, fr, proc), write)
  ensures acc(diz.channel_hist_act, write)
  ensures acc(diz.channel_hist_value, write)
  ensures acc(diz.channel_hist_write, write)
  ensures acc(diz.channel_hist_action, write)
  ensures diz.channel_hist_value == diz.channel_hist_act
  ensures diz.channel_hist_value == old(diz.channel_hist_value)
{
  inhale false
}

method method_Future_Send__Integer__Integer_commit(diz: Ref, current_thread_id: Int, fr: frac, proc: Process, rank: Int, msg: Int)
  requires diz != null
  requires 0 <= current_thread_id
  requires frac_val(fr) != none
  requires acc(hist_do_method_Future_Send__Integer__Integer(diz, fr, proc), write)
  requires write != none
  requires acc(diz.channel_hist_act, write)
  requires acc(diz.channel_hist_value, write)
  requires acc(diz.channel_hist_write, write)
  requires acc(diz.channel_hist_action, write)
  requires 0 <= rank && rank < |diz.channel_hist_value|
  requires |diz.channel_hist_value| == |diz.channel_hist_act|
  requires diz.channel_hist_value[rank] == diz.channel_hist_act[rank] ++ Seq(msg)
  requires (forall i: Int :: { diz.channel_hist_value[i] } { diz.channel_hist_act[i] } 0 <= i && i < |diz.channel_hist_value| && i != rank ==> diz.channel_hist_value[i] == diz.channel_hist_act[i])
  ensures frac_val(fr) != none
  ensures acc(hist_idle(diz, fr, proc), write)
  ensures acc(diz.channel_hist_value, write)
  ensures acc(diz.channel_hist_hist, write)
  ensures diz.channel_hist_value == old(diz.channel_hist_value)
{
  inhale false
}

method method_Future_Recv__Integer__Integer_begin(diz: Ref, current_thread_id: Int, fr: frac, proc: Process, rank: Int, msg: Int)
  requires diz != null
  requires 0 <= current_thread_id
  requires frac_val(fr) != none
  requires acc(hist_idle(diz, fr, p_seq(p_method_Future_Recv__Integer__Integer(rank, msg), proc)), write)
  requires write != none
  requires acc(diz.channel_hist_value, write)
  requires acc(diz.channel_hist_hist, write)
  requires 0 <= rank && rank < |diz.channel_hist_value|
  ensures frac_val(fr) != none
  ensures acc(hist_do_method_Future_Recv__Integer__Integer(diz, fr, proc), write)
  ensures acc(diz.channel_hist_act, write)
  ensures acc(diz.channel_hist_value, write)
  ensures acc(diz.channel_hist_write, write)
  ensures acc(diz.channel_hist_action, write)
  ensures diz.channel_hist_value == diz.channel_hist_act
  ensures diz.channel_hist_value == old(diz.channel_hist_value)
{
  inhale false
}

method method_Future_Recv__Integer__Integer_commit(diz: Ref, current_thread_id: Int, fr: frac, proc: Process, rank: Int, msg: Int)
  requires diz != null
  requires 0 <= current_thread_id
  requires frac_val(fr) != none
  requires acc(hist_do_method_Future_Recv__Integer__Integer(diz, fr, proc), write)
  requires write != none
  requires acc(diz.channel_hist_act, write)
  requires acc(diz.channel_hist_value, write)
  requires acc(diz.channel_hist_write, write)
  requires acc(diz.channel_hist_action, write)
  requires 0 <= rank && rank < |diz.channel_hist_value|
  requires |diz.channel_hist_value| == |diz.channel_hist_act|
  requires Seq(msg) ++ diz.channel_hist_value[rank] == diz.channel_hist_act[rank]
  requires (forall i: Int :: { diz.channel_hist_value[i] } { diz.channel_hist_act[i] } 0 <= i && i < |diz.channel_hist_value| && i != rank ==> diz.channel_hist_value[i] == diz.channel_hist_act[i])
  ensures frac_val(fr) != none
  ensures acc(hist_idle(diz, fr, proc), write)
  ensures acc(diz.channel_hist_value, write)
  ensures acc(diz.channel_hist_hist, write)
  ensures diz.channel_hist_value == old(diz.channel_hist_value)
{
  inhale false
}

method method_Future_Done__Integer__Integer_begin(diz: Ref, current_thread_id: Int, fr: frac, proc: Process, rank: Int, v: Int)
  requires diz != null
  requires 0 <= current_thread_id
  requires frac_val(fr) != none
  requires acc(hist_idle(diz, fr, p_seq(p_method_Future_Done__Integer__Integer(rank, v), proc)), write)
  requires write != none
  requires acc(diz.results_hist_value, write)
  requires acc(diz.results_hist_hist, write)
  requires 0 <= rank && rank < |diz.results_hist_value|
  ensures frac_val(fr) != none
  ensures acc(hist_do_method_Future_Done__Integer__Integer(diz, fr, proc), write)
  ensures acc(diz.results_hist_act, write)
  ensures acc(diz.results_hist_value, write)
  ensures acc(diz.results_hist_write, write)
  ensures acc(diz.results_hist_action, write)
  ensures diz.results_hist_value == diz.results_hist_act
  ensures diz.results_hist_value == old(diz.results_hist_value)
{
  inhale false
}

method method_Future_Done__Integer__Integer_commit(diz: Ref, current_thread_id: Int, fr: frac, proc: Process, rank: Int, v: Int)
  requires diz != null
  requires 0 <= current_thread_id
  requires frac_val(fr) != none
  requires acc(hist_do_method_Future_Done__Integer__Integer(diz, fr, proc), write)
  requires write != none
  requires acc(diz.results_hist_act, write)
  requires acc(diz.results_hist_value, write)
  requires acc(diz.results_hist_write, write)
  requires acc(diz.results_hist_action, write)
  requires 0 <= rank && rank < |diz.results_hist_value|
  requires |diz.results_hist_value| == |diz.results_hist_act|
  requires diz.results_hist_value[rank] == v
  requires (forall i: Int :: { diz.results_hist_value[i] } { diz.results_hist_act[i] } 0 <= i && i < |diz.results_hist_value| && i != rank ==> diz.results_hist_value[i] == diz.results_hist_act[i])
  ensures frac_val(fr) != none
  ensures acc(hist_idle(diz, fr, proc), write)
  ensures acc(diz.results_hist_value, write)
  ensures acc(diz.results_hist_hist, write)
  ensures diz.results_hist_value == old(diz.results_hist_value)
{
  inhale false
}

/* REMOVING THIS MAKES IT STABLE? UNTESTED. OTHERS AS WELL */
method hist_set_channel(diz: Ref, current_thread_id: Int, value: Seq[Seq[Int]])
  requires diz != null
  requires 0 <= current_thread_id
  requires acc(diz.channel_hist_value, write)
  requires acc(diz.channel_hist_write, write)
  ensures acc(diz.channel_hist_value, write) && diz.channel_hist_value == value
  ensures acc(diz.channel_hist_write, write)
{
  inhale false
}

/* PROBLEMATIC LEMMA */
method method_Program_lemma_sigmaRecv_choice__Future__Integer__Integer__Integer__Integer__Integer(diz: Ref, current_thread_id: Int, globals: Ref, f: Ref, rank: Int, v: Int, w: Int, x: Int, n: Int, q: frac)
  requires diz != null
  requires 0 <= current_thread_id
  requires frac_val(q) != none
  requires acc(diz.field_Program_maxvalue, 1 / 2)
  requires acc(diz.field_Program_size, 1 / 2)
  requires 0 <= diz.field_Program_size
  requires f != null
  requires acc(f.channel_hist_value, 1 / 2)
  requires acc(f.channel_hist_hist, 1 / 2)
  requires 0 <= rank && rank < diz.field_Program_size
  requires 0 <= x && x <= w
  requires acc(hist_idle(f, q, p_method_Future_SigmaRecv__Integer__Integer__Integer__Integer__Integer__Integer(rank, diz.field_Program_size, v, w, diz.field_Program_maxvalue, n)), write)
  ensures frac_val(q) != none
  ensures acc(diz.field_Program_maxvalue, 1 / 2)
  ensures acc(diz.field_Program_size, 1 / 2)
  ensures 0 <= diz.field_Program_size
  ensures f != null
  ensures acc(f.channel_hist_value, 1 / 2)
  ensures acc(f.channel_hist_hist, 1 / 2)
  ensures 0 <= rank && rank < diz.field_Program_size
  ensures diz.field_Program_maxvalue == old(diz.field_Program_maxvalue)
  ensures diz.field_Program_size == old(diz.field_Program_size)
  ensures f.channel_hist_value == old(f.channel_hist_value)
  ensures acc(hist_idle(f, q, p_seq(p_method_Future_Recv__Integer__Integer((rank - 1) % diz.field_Program_size, x), p_method_Future_Check__Integer__Integer__Integer__Integer__Integer__Integer(rank, diz.field_Program_size, v, x, diz.field_Program_maxvalue, n))), write)

/* PROBLEMATIC METHOD */
method method_Program_mpi_recv__Integer(diz: Ref, current_thread_id: Int, globals: Ref, rank: Int, v: Int, n: Int, q1: frac, q2: frac) returns (sys__result: Int)
  requires diz != null
  requires frac_val(q1) != none && frac_val(q2) != none
  requires acc(diz.field_Program_size, frac_val(q1))
  requires acc(diz.field_Program_maxvalue, frac_val(q1))
  requires 0 <= rank && rank < diz.field_Program_size
  requires acc(diz.field_Program_initialised, frac_val(q1))
  requires diz.field_Program_initialised
  requires acc(diz.field_Program_f, frac_val(q1))
  requires diz.field_Program_f != null
  requires 0 <= current_thread_id
  requires acc(hist_idle(diz.field_Program_f, q2, p_method_Future_SigmaRecv__Integer__Integer__Integer__Integer__Integer__Integer(rank, diz.field_Program_size, v, diz.field_Program_maxvalue - 1, diz.field_Program_maxvalue, n)), write)
{
  var sys__local__result__9: Int
  var stop__10: Bool
  var res__11: Int
  var __flatten_11__12: Ref
  var __flatten_12__13: Ref
  var __flatten_14__14: Process
  var __flatten_16__15: Ref
  var __flatten_17__16: Seq[Seq[Int]]
  var __flatten_19__17: Process
  stop__10 := false
  while (!stop__10)
    invariant frac_val(q1) != none && frac_val(q2) != none
    invariant acc(diz.field_Program_size, frac_val(q1))
    invariant acc(diz.field_Program_maxvalue, frac_val(q1))
    invariant 0 <= rank && rank < diz.field_Program_size
    invariant acc(diz.field_Program_initialised, frac_val(q1))
    invariant diz.field_Program_initialised
    invariant acc(diz.field_Program_f, frac_val(q1))
    invariant diz.field_Program_f != null
    invariant diz.field_Program_size == old(diz.field_Program_size)
    invariant diz.field_Program_maxvalue == old(diz.field_Program_maxvalue)
    invariant diz.field_Program_f == old(diz.field_Program_f)
    invariant 0 <= rank && rank < diz.field_Program_size
    invariant !stop__10 ==> acc(hist_idle(diz.field_Program_f, q2, p_method_Future_SigmaRecv__Integer__Integer__Integer__Integer__Integer__Integer(rank, diz.field_Program_size, v, diz.field_Program_maxvalue - 1, diz.field_Program_maxvalue, n)), write)
    invariant stop__10 ==> acc(hist_idle(diz.field_Program_f, q2, p_method_Future_Check__Integer__Integer__Integer__Integer__Integer__Integer(rank, diz.field_Program_size, v, res__11, diz.field_Program_maxvalue, n)), write)
    invariant stop__10 ==> 0 <= res__11 && res__11 < diz.field_Program_maxvalue 
  {
    inhale acc(method_Program_lock_invariant(diz, globals), write)
    unfold acc(method_Program_lock_invariant(diz, globals), write)
    inhale acc(method_Program_lock_held(diz, globals), write)
    __flatten_11__12 := diz.field_Program_f
    if (0 < |__flatten_11__12.channel_hist_value[(rank - 1) % diz.field_Program_size]|) {
      __flatten_12__13 := diz.field_Program_f
      res__11 := __flatten_12__13.channel_hist_value[(rank - 1) % diz.field_Program_size][0]
      // assert
      assert acc(hist_idle(diz.field_Program_f, q2, p_method_Future_SigmaRecv__Integer__Integer__Integer__Integer__Integer__Integer(rank, diz.field_Program_size, v, diz.field_Program_maxvalue - 1, diz.field_Program_maxvalue, n)), write)
      /* PROBLEMATIC CALL */
      method_Program_lemma_sigmaRecv_choice__Future__Integer__Integer__Integer__Integer__Integer(diz, current_thread_id, globals, diz.field_Program_f, rank, v, diz.field_Program_maxvalue - 1, res__11, n, q2)
    }
    inhale false
  }
  inhale false
}

