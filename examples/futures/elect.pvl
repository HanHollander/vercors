// -*- tab-width:2 ; indent-tabs-mode:nil -*-
//:: case LeaderElect
//:: tool silicon
//:: suite problem-fail
//:: option --check-history

class Future {

    /* ** Communication primitives */

    seq<seq<int>> channel; // communication channels
    seq<int> results; // results from leader elections

    modifies channel;
    context 0 <= rank && rank < |channel|;
    ensures |channel| == |\old(channel)|;
    ensures channel[rank] == \old(channel[rank]) + seq<int> { msg };
    ensures (\forall int i; 0 <= i && i < |channel| && i != rank; channel[i] == \old(channel[i]));
    process Send(int rank, int msg);

    modifies channel;
    context 0 <= rank && rank < |channel|;
    ensures |channel| == |\old(channel)|;
    ensures seq<int> { msg } + channel[rank] == \old(channel[rank]);
    ensures (\forall int i; 0 <= i && i < |channel| && i != rank; channel[i] == \old(channel[i]));
    process Recv(int rank, int msg);


    /* ** Leader election actions */

    modifies results;
    context 0 <= rank && rank < |results|;
    ensures |results| == |\old(results)|;
    ensures results[rank] == v;
    ensures (\forall int i; 0 <= i && i < |results| && i != rank; results[i] == \old(results[i]));
    process Done(int rank, int v);

    // `v` is the current highest value encountered by the participant
    // `w` is the value that is being received
    // `n` is the number of rounds we already had
    requires 0 <= w;
    requires 0 <= rank && rank < size && size == |channel|;
    process SigmaRecv(int rank, int size, int v, int w, int max, int n) =
        0 < w ? (Recv((rank - 1) % size, w) * Check(rank, size, v, w, max, n)) + SigmaRecv(rank, size, v, w - 1, max, n) :
                        (Recv((rank - 1) % size, w) * Check(rank, size, v, w, max, n));

    // compares the received value `w` with the current highest value `v` of a participant, which continues with the biggest of the two values.
    requires 0 <= w;
    requires 0 <= rank && rank < size && size == |channel|;
    process Check(int rank, int size, int v, int w, int max, int n) =
        Elect(rank, size, v <= w ? w : v, max, n + 1);

    requires n <= size;
    requires 0 <= rank && rank < size && size == |channel|;
    process Elect(int rank, int size, int v, int max, int n) =
        n < size ? Send((rank + 1) % size, v) * SigmaRecv(rank, size, v, max - 1, max, n) : Done(rank, v);
}

class Program {
    boolean initialised;
    int size;
    int maxvalue;
    Future f;

    resource lock_invariant() =
        Perm(initialised, 1\2) ** Perm(size, 1\2) **
        Perm(maxvalue, 1\2) ** 0 < maxvalue **
        (initialised ? Perm(f, 1\2) ** f != null: true) **
        (initialised ? HPerm(f.channel, write) ** size == |f.channel| : true) **
        (initialised ? HPerm(f.results, write) ** size == |f.results| : true) **
        (initialised ==> (\forall int i; 0 <= i && i < size; (\forall int j; 0 <= j && j < |f.channel[i]|; 0 <= f.channel[i][j] && f.channel[i][j] < maxvalue)));

    requires 0 < max;
    requires f != null;
    requires HPerm(f.channel, write);
    requires HPerm(f.results, write);
    requires |f.results| == |f.channel|;
    requires |f.channel| == size;
    requires (\forall int i; 0 <= i && i < |f.channel|; (\forall int j; 0 <= j && j < |f.channel[i]|; 0 <= f.channel[i][j] && f.channel[i][j] < max));
    ensures Perm(this.f, 1\2) ** this.f == f;
    ensures Perm(this.size, 1\2) ** this.size == size;
    ensures Perm(this.maxvalue, 1\2) ** this.maxvalue == max;
    ensures Perm(this.initialised, 1\2) ** this.initialised;
    Program(Future f, int size, int max) {
    inhale false;
    }


    /* ** Auxiliary operations */

    // @param `xs[i]` is the position that is considered now
    // @param `xs[j]` is the current highest position
    // @result the index of the highest value in `xs`
    requires 0 <= i && i <= |xs|;
    requires 0 <= j && j < |xs|;
    requires (\forall int l; 0 <= l && l < i; xs[l] <= xs[j]);
    ensures 0 <= \result && \result < |xs|;
    ensures xs[j] <= xs[\result];
    ensures (\forall int l; i <= l && l < |xs|; xs[l] <= xs[\result]);
    pure static int maxint(seq<int> xs, int i, int j) =
        i < |xs| ? (xs[j] <= xs[i] ? maxint(xs, i + 1, i) : maxint(xs, i + 1, j)) : j;

    /* ** Auxiliary lemmas */

    given frac q;
    requires q != none;
    requires Perm(maxvalue, 1\2);
    requires Perm(size, 1\2) ** 0 <= size;
    requires f != null ** HPerm(f.channel, 1\2);
    requires 0 <= rank && rank < size;
    requires 0 <= x && x <= w;
    requires Future(f, q, f.SigmaRecv(rank, size, v, w, maxvalue, n)); /* PROBLEMATIC REQUIRES? */
    void lemma_sigmaRecv_choice(Future f, int rank, int v, int w, int x, int n);

    /* ** Message passing primitives */

    given int v;
    given int n;
    given frac q1; // ownership of the program `p`
    given frac q2; // ownershow of the future `f`
    requires q1 != none && q2 != none;
    requires Perm(size, q1) ** Perm(maxvalue, q1);
    requires 0 <= rank && rank < size;
    requires Perm(initialised, q1) ** initialised;
    requires Perm(f, q1) ** f != null;
    requires Future(f, q2, f.SigmaRecv(rank, size, v, maxvalue - 1, maxvalue, n));
    void mpi_recv(int rank) { /* UNSTABLE METHOD? */
        lock this;
    
        if (0 < |f.channel[(rank - 1) % size]|) {
          // going to contain the resulting, received value
          int res = head(f.channel[(rank - 1) % size]); // this is the value we'll receive

          assert Future(f, q2, f.SigmaRecv(rank, size, v, maxvalue - 1, maxvalue, n));
          lemma_sigmaRecv_choice(f, rank, v, maxvalue - 1, res, n) with { q = q2; }; /* ERROR UNSTABLE? */
        }
    }
}
