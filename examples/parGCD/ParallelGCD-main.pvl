class ParallelGCD {
  requires a > 0 ** b > 0;
  static int gcd(int a,int b)=a==b?a:(a>b?gcd(a-b,b):gcd(a,b-a));

  requires x > 0 ** y > 0 ;
  ensures  \result==gcd(x,y);
  int gcd2(int x,int y){
    Future F=new Future();
    F.x=x; F.y=y;
    create F, F.gcd();
    split  F, 1/2, F.tx(), 1/2, F.ty();

    invariant inv( HPerm(F.x,write) ** HPerm(F.y,write) ** F.x > 0 ** F.y > 0 ){
      par T0()
        requires Future(F,1/2,F.tx());
        ensures Future(F,1/2,empty);
      {
        boolean run = true;
        loop_invariant run?Future(F,1/2,F.tx()):Future(F,1/2,empty);
        while(run){
          atomic(inv){
            if(F.x > F.y){
              choose F, 1/2, F.tx(), F.decr_x()*F.tx();
              action(F,1/2,F.tx(),F.decr_x()){ F.x = F.x - F.y; }
            }
            if(F.x==F.y){
              choose F, 1/2, F.tx(), F.done();
              action(F,1/2,empty,F.done()){ run=false; }
        } } }
      } and T1() #\(\cdots\)#
    }
    merge F, 1/2, empty, 1/2, empty;
    destroy F;
    return F.x;
  }
}
