

class SCC {

    // determines whether `C` is a component in a graph with size `N`
    static inline pure boolean Component(int N, set<int> C) =
        0 < |C| && |C| <= N &&
        (\forall int v; v in C; 0 <= v && v < N);

    // determines whether `G` is an adjacency matrix of size `N`
    static inline pure boolean AdjacencyMatrix(int N, seq<seq<boolean>> G) =
        |G| == N && (\forall seq<boolean> e; e in G; |e| == N);

    /* -------------------------------------------------------------------------------------------------------------- */

    // determines whether `P` is a path from `x` to `y` in the graph `G`.
    requires AdjacencyMatrix(N, G);
    pure boolean Path(int N, seq<seq<boolean>> G, int x, int y, seq<int> P) =
        0 <= x && x < N && 0 <= y && y < N &&
        0 < |P| && P[0] == x && P[|P| - 1] == y &&
        (\forall int j; 0 <= j && j < |P|; 0 <= P[j] && P[j] < N) &&
        (\forall int j; 0 <= j && j < |P| - 1; G[P[j]][P[j + 1]]);

    // existential quantification over paths in `G` of length at least `len`.
    requires AdjacencyMatrix(N, G);
    pure boolean ExPath(int N, seq<seq<boolean>> G, int x, int y, int len) =
        (\exists seq<int> P; len <= |P|; Path(N, G, x, y, P));

    // determines whether `P` is a path from `x` to `y` in the graph `G` visiting only states in C.
    requires AdjacencyMatrix(N, G);
    pure boolean FittingPath(int N, seq<seq<boolean>> G, int x, int y, seq<int> P, set<int> C) =
        Path(N, G, x, y, P) &&
        (\forall int v; v in P; v in C);

    // existential quantification over fitting paths in `G` of length at least `len`.
    requires AdjacencyMatrix(N, G);
    pure boolean ExFittingPath(int N, seq<seq<boolean>> G, int x, int y, int len, set<int> C) =
        (\exists seq<int> P; len <= |P|; FittingPath(N, G, x, y, P, C));

    /* -------------------------------------------------------------------------------------------------------------- */

    requires Component(N, C);
    requires AdjacencyMatrix(N, G);
    pure boolean PSCC(int N, seq<seq<boolean>> G, set<int> C) =
        (\forall int v; v in C; (\forall int w; w in C && w != v; ExPath(N, G, v, w, 1) &&
                                                                  ExPath(N, G, w, v, 1)));
    requires Component(N, C);
    requires AdjacencyMatrix(N, G);
    pure boolean FSCC(int N, seq<seq<boolean>> G, set<int> C) =
        (\forall int v; v in C; (\forall int w; w in C && w != v; ExFittingPath(N, G, v, w, 1, C) &&
                                                                  ExFittingPath(N, G, w, v, 1, C)));
    requires Component(N, C);
    requires AdjacencyMatrix(N, G);
    pure boolean SCC(int N, seq<seq<boolean>> G, set<int> C) =
        FSCC(N, G, C) &&
        (\forall set<int> Cp; Component(N, Cp) && FSCC(N, G, Cp) && Cp != C; !(\forall int i; i in C; i in Cp));



    void main() {

        int N = 6;
        seq<seq<boolean>> G = [[false, true, false, false, false, false],
                               [false, false, true, true, false, false],
                               [false, false, false, false, true, false],
                               [true, false, false, false, false, false],
                               [false, false, false, true, false, false],
                               [false, false, false, false, false, false]];



        // Path
        seq<int> P1 = [1, 2, 4];
        assert Path(N, G, 1, 4, P1);
        assert !Path(N, G, 2, 4, P1);
        assert !Path(N, G, 1, 3, P1);
        assert !Path(N, G, 2, 3, P1);

        // ExPath
        // assert !ExPath(N, G, 1, 5, 1);  // difficult to prove
        assert ExPath(N, G, 1, 4, 1);  // provable with witness: `assert Path(N, G, 1, 4, P1);`

        // FittingPath
        set<int> C1 = {0, 1, 3};
        set<int> C2 = {0, 1, 2, 3, 4};
        seq<int> P2 = [0, 1, 3];
        seq<int> P3 = [0, 1, 2, 4, 3];
        assert Path(N, G, 0, 3, P2);
        assert Path(N, G, 0, 3, P3);
        assert FittingPath(N, G, 0, 3, P2, C1);
        assert (4 in P3) && !(4 in C1);
        assert !FittingPath(N, G, 0, 3, P3, C1);  // provable with witness `assert (4 in P3) && !(4 in C1);`
        assert FittingPath(N, G, 0, 3, P2, C2);
        assert FittingPath(N, G, 0, 3, P3, C2);

        // ExFittingPath
        assert !ExFittingPath(N, G, 0, 4, 1, C1);  // difficult to prove
        assert ExFittingPath(N, G, 0, 3, 1, C1);  // provable with witness: `assert FittingPath(N, G, 0, 3, P2, C1);`

        set<int> PSCC1 = {0, 1, 2};
        set<int> FSCC1 = {0, 1, 3};
        set<int> SCC1 = {0, 1, 2, 3, 4};
        set<int> SCC2 = {5};
        set<int> notComponent = {1, 3, 4, 6};

        // Component
        assert Component(N, PSCC1);
        assert Component(N, FSCC1);
        assert Component(N, SCC1);
        assert Component(N, SCC2);
        assert !Component(N, notComponent);

        // PSCC
        assert (\forall int v; v in PSCC1; (\forall int w; w in PSCC1 && w != v; ExPath(N, G, v, w, 1) &&
                                                                                 ExPath(N, G, w, v, 1)));
        assert PSCC(N, G, PSCC1);
        assert PSCC(N, G, SCC1);
        assert PSCC(N, G, SCC2);



    }









}