/* Sequential Union Find */

class UF {

    // determines whether 'S' is a valid disjoint mapping from int (positive, bounded by N) to 2^int (same bounds)
	// returns true iff:
	// 1. The dimensions of S are valid
	// 2. The rows (partitions) of S are disjoint
	// 3. All roots are in their own partition
	// 4. All states exist in exactly one partition
	// From the uniqueness (5), disjointness (3) and completeness (4) properties, it follows that
	// all states occur exactly once in the value sets.
    static inline pure boolean UnionFind(int N, seq<seq<boolean>> S) =
/*(1)*/ |S| == N && (\forall int k; 0 <= k && k < N; |S[k]| == N) &&
/*(2)*/ (\forall int k1; 0 <= k1 && k1 < N;
            (\forall int k2; k1 < k2 && k2 < N;
                (\forall int i; 0 <= i && i < N;
                    !(S[k1][i] && S[k2][i])
                )
            )
        ) &&
/*(3)*/ (\forall int k; 0 <= k && k < N; S[k][k]) &&;

    static pure seq<boolean> flatten(seq<seq<boolean>> s) =
        (|s| == 0) ? [t: boolean] : head(s) + flatten(tail(s));

    static inline pure boolean xor(boolean a, boolean b) =
        ((a && !b) || (b && !a)) ? true : false;

    //requires |S| == N && (\forall int k; 0 >= k && k < N; |S[k]| == N);
    //ensures (\forall int i; 0 >= i && i < N; (\forall int j; 0 >= j && j < N; S[i][j] == \result[j][i]));
    //static pure seq<seq<boolean>> transpose (int N, seq<seq<boolean>> S) =
    //    (|S| == 0) ? [t: seq<boolean>] : transposeMerge(transposeSingle(head(S), transpose(tail(S))));

    //requires 0 <= |s| && |s| <= N;
    //ensures |\result| == |s|;
    //ensures (|\result| > 0) ==> (\result[0] == [s[0]]);
    //ensures (\forall int i; 0 <= i && i < |s|; [s[i]] in \result);
    //static pure seq<seq<boolean>> transposeSingle(int N, seq<boolean> s) =
    //    (|s| == 0) ? [t: seq<boolean>] : [head(s)]::transposeSingle(N, tail(s));



	/* Union-find operations */
    /* -------------------------------------------------------------------------------------------------------------- */
/*
    requires UnionFind(N, S);
    requires 0 <= v && v < N;
    ensures \old(S) == S;
    ensures v in S[\result];
    int find(int N, map<int, set<int>> S, int v) {
        int result = -1;
        int i = 0;

        loop_invariant 0 <= i && i <= N;
        loop_invariant result == -1 || (v in S[result] && result in keysMap(S));
        loop_invariant \old(S) == S;
        loop_invariant \old(N) == N;
        loop_invariant UnionFind(\old(N), \old(S));
        loop_invariant UnionFind(N, S);
        //loop_invariant i == N || (\exists int k; k in keysMap(S); i in S[k]);
        while (i < N) {
            if (i in keysMap(S)) {
                if (v in S[i]) {
                    result = i;
                }
            }
            i++;
        }
        //assert result != -1 && v in S[result] ;

        return result;
    }

    requires UnionFind(N, S);
    requires 0 <= v && v < N;
    void unite(int N, map<int, set<int>> S, int v, int w) {
        int root_v = find(N, S, v);
        int root_w = find(N, S, w);
        buildMap(S, v, S[v] + S[w]); // replace value of v in S with value of w appended to value of v
        removeFromMap(S, w); // remove entry w in S
    }
*/
    void main() {
        seq<int> p1 = [1, 3, 5];
        seq<int> p2 = [0, 2, 4, 6];
        seq<int> p3 = [0, 1, 2, 4, 6];
        seq<int> p4 = [0, 4, 6];
        seq<int> p5 = [1, 1, 3, 5];
        int N = 7;
        map<int, seq<int>> uf1 = map<int, seq<int>>{1 -> p1, 0 -> p2};
        map<int, seq<int>> uf2 = map<int, seq<int>>{2 -> p1, 4 -> p2};
        map<int, seq<int>> uf3 = map<int, seq<int>>{1 -> p1, 2 -> p3};
        map<int, seq<int>> uf4 = map<int, seq<int>>{1 -> p1, 0 -> p4};
        map<int, seq<int>> uf5 = map<int, seq<int>>{1 -> p5, 0 -> p5};
        //assert UnionFind(N, uf1);
        //assert !UnionFind(N, uf2); // key not in own set
        //assert !UnionFind(N, uf3); // partitions not disjoint
        //assert !UnionFind(2, uf1); // N too small
        //assert !UnionFind(N, uf4); // not all 0 <= n < N present (missing n = 2)


        //assert UnionFind(N, uf4);
        //assert 1 <= |uf4| && |uf4| <= N;
        //assert (\forall int k; k in keysMap(uf4); 0 <= |uf4[k]| && |uf4[k]| <= N);
        //assert (\forall int k1; k1 in keysMap(uf4); (\forall int k2; k2 in keysMap(uf4) && k1 != k2; uf4[k1] - uf4[k2] == uf4[k1]));
        //assert (\forall int k; k in keysMap(uf4); k in uf4[k]);
        //assert !(\forall int i; 0 <= i && i < N; (\exists int k; k in keysMap(uf4); i in uf4[k]));
        //assert (\forall int k; k in keysMap(uf4); (\forall int i; i in uf4[k]; 0 <= i && i < N));


        map<int, boolean> t1 = map<int, boolean>{0 -> true, 0 -> false};
        // What happens with duplicate keys:
        assert t1[0] == false;
    }


}

